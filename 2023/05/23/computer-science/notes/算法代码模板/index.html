<!-- build time:Mon May 29 2023 19:37:30 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="永远少年！" href="http://红叶.top/rss.xml"><link rel="alternate" type="application/atom+xml" title="永远少年！" href="http://红叶.top/atom.xml"><link rel="alternate" type="application/json" title="永远少年！" href="http://红叶.top/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="学习心得"><link rel="canonical" href="http://红叶.top/2023/05/23/computer-science/notes/%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/"><title>算法板子 - 学习小记 - 计算机科学 | Red-Leaf = 永远少年！ = 吹灭读书灯，一身都是月</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">算法板子</h1><div class="meta"><span class="item" title="创建时间：2023-05-23 15:49:38"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-05-23T15:49:38+08:00">2023-05-23</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Red-Leaf</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://t.mwm.moe/ycy?153430"></li><li class="item" data-background-image="https://t.mwm.moe/ycy?519174"></li><li class="item" data-background-image="https://t.mwm.moe/ycy?550742"></li><li class="item" data-background-image="https://t.mwm.moe/ycy?506257"></li><li class="item" data-background-image="https://t.mwm.moe/ycy?69097"></li><li class="item" data-background-image="https://t.mwm.moe/ycy?148208"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/" itemprop="item" rel="index" title="分类于 计算机科学"><span itemprop="name">计算机科学</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/notes/" itemprop="item" rel="index" title="分类于 学习小记"><span itemprop="name">学习小记</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://红叶.top/2023/05/23/computer-science/notes/%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="十月秋枫"><meta itemprop="description" content="吹灭读书灯，一身都是月,  欢迎来到我的笔记空间꒰⑅•ᴗ•⑅꒱,在这里,你可以阅读我的学习笔记并提出独到的见解~我们将互相学习交流知识,共同进步( ๑╹ ꇴ╹) ｸﾞｯ!"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="永远少年！"></span><div class="body md" itemprop="articleBody"><h1 id="算法代码模板"><a class="anchor" href="#算法代码模板">#</a> 算法代码模板</h1><h2 id="第一章-基础算法"><a class="anchor" href="#第一章-基础算法">#</a> 第一章 基础算法</h2><h3 id="快速排序"><a class="anchor" href="#快速排序">#</a> 快速排序</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
void quick_sort(int q[], int l, int r)
&#123;
    if (l &gt;&#x3D; r) return;

    int i &#x3D; l - 1, j &#x3D; r + 1, x &#x3D; q[l + r &gt;&gt; 1];
    while (i &lt; j)
    &#123;
        do i ++ ; while (q[i] &lt; x);
        do j -- ; while (q[j] &gt; x);
        if (i &lt; j) swap(q[i], q[j]);
    &#125;
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="归并排序"><a class="anchor" href="#归并排序">#</a> 归并排序</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
void merge_sort(int q[], int l, int r)
&#123;
    if (l &gt;&#x3D; r) return;

    int mid &#x3D; l + r &gt;&gt; 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);

    int k &#x3D; 0, i &#x3D; l, j &#x3D; mid + 1;
    while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r)
        if (q[i] &lt;&#x3D; q[j]) tmp[k ++ ] &#x3D; q[i ++ ];
        else tmp[k ++ ] &#x3D; q[j ++ ];

    while (i &lt;&#x3D; mid) tmp[k ++ ] &#x3D; q[i ++ ];
    while (j &lt;&#x3D; r) tmp[k ++ ] &#x3D; q[j ++ ];

    for (i &#x3D; l, j &#x3D; 0; i &lt;&#x3D; r; i ++, j ++ ) q[i] &#x3D; tmp[j];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="整数二分算法"><a class="anchor" href="#整数二分算法">#</a> 整数二分算法</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
bool check(int x) &#123;&#x2F;* ... *&#x2F;&#125; &#x2F;&#x2F; 检查x是否满足某种性质

&#x2F;&#x2F; 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
&#123;
    while (l &lt; r)
    &#123;
        int mid &#x3D; l + r &gt;&gt; 1;
        if (check(mid)) r &#x3D; mid;    &#x2F;&#x2F; check()判断mid是否满足性质
        else l &#x3D; mid + 1;
    &#125;
    return l;
&#125;
&#x2F;&#x2F; 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l, int r)
&#123;
    while (l &lt; r)
    &#123;
        int mid &#x3D; l + r + 1 &gt;&gt; 1;
        if (check(mid)) l &#x3D; mid;
        else r &#x3D; mid - 1;
    &#125;
    return l;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="浮点数二分算法"><a class="anchor" href="#浮点数二分算法">#</a> 浮点数二分算法</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
bool check(double x) &#123;&#x2F;* ... *&#x2F;&#125; &#x2F;&#x2F; 检查x是否满足某种性质

double bsearch_3(double l, double r)
&#123;
    const double eps &#x3D; 1e-6;   &#x2F;&#x2F; eps 表示精度，取决于题目对精度的要求
    while (r - l &gt; eps)
    &#123;
        double mid &#x3D; (l + r) &#x2F; 2;
        if (check(mid)) r &#x3D; mid;
        else l &#x3D; mid;
    &#125;
    return l;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="高精度加法"><a class="anchor" href="#高精度加法">#</a> 高精度加法</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
&#x2F;&#x2F; C &#x3D; A + B, A &gt;&#x3D; 0, B &gt;&#x3D; 0	用下标较大的数组存储高位
vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)
&#123;
    if (A.size() &lt; B.size()) return add(B, A);

    vector&lt;int&gt; C;
    int t &#x3D; 0;
    for (int i &#x3D; 0; i &lt; A.size(); i ++ )
    &#123;
        t +&#x3D; A[i];
        if (i &lt; B.size()) t +&#x3D; B[i];
        C.push_back(t % 10);
        t &#x2F;&#x3D; 10;
    &#125;

    if (t) C.push_back(t);
    return C;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p><pre class="line-numbers language-java" data-language="java"><code class="language-java">
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token class-name">A</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token class-name">B</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token class-name">B</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">B</span><span class="token punctuation">,</span> <span class="token class-name">A</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>		
	<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token class-name">C</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">A</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		temp <span class="token operator">+=</span> <span class="token class-name">A</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token class-name">B</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			temp <span class="token operator">+=</span> <span class="token class-name">B</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token class-name">C</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>temp <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		temp <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>		
	<span class="token keyword">if</span><span class="token punctuation">(</span>temp <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token class-name">C</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token class-name">C</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token class-name">C</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">getList</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>num <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>num <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		num <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> list<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">123456</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">654</span><span class="token punctuation">;</span>
	<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token class-name">A</span> <span class="token operator">=</span> <span class="token function">getList</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token class-name">B</span> <span class="token operator">=</span> <span class="token function">getList</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token class-name">C</span> <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">,</span> <span class="token class-name">B</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="高精度减法"><a class="anchor" href="#高精度减法">#</a> 高精度减法</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
&#x2F;&#x2F; C &#x3D; A - B, 满足A &gt;&#x3D; B, A &gt;&#x3D; 0, B &gt;&#x3D; 0
vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)
&#123;
    vector&lt;int&gt; C;
    for (int i &#x3D; 0, t &#x3D; 0; i &lt; A.size(); i ++ )
    &#123;
        t &#x3D; A[i] - t;
        if (i &lt; B.size()) t -&#x3D; B[i];
        C.push_back((t + 10) % 10);
        if (t &lt; 0) t &#x3D; 1;
        else t &#x3D; 0;
    &#125;

    while (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();
    return C;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p><pre class="line-numbers language-java" data-language="java"><code class="language-java">
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token class-name">A</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token class-name">B</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token class-name">C</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">A</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		temp <span class="token operator">=</span> <span class="token class-name">A</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> temp<span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token class-name">B</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			temp <span class="token operator">-=</span> <span class="token class-name">B</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token class-name">C</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">(</span>temp <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		temp <span class="token operator">=</span> temp <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>		
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token class-name">C</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token class-name">C</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">C</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token class-name">C</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">C</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token class-name">C</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
	<span class="token keyword">return</span> <span class="token class-name">C</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">getList</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>num <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>num <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		num <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> list<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">123456</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">654</span><span class="token punctuation">;</span>
	<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token class-name">A</span> <span class="token operator">=</span> <span class="token function">getList</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token class-name">B</span> <span class="token operator">=</span> <span class="token function">getList</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token class-name">C</span> <span class="token operator">=</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">,</span> <span class="token class-name">B</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="高精度乘低精度"><a class="anchor" href="#高精度乘低精度">#</a> 高精度乘低精度</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
&#x2F;&#x2F; C &#x3D; A * b, A &gt;&#x3D; 0, b &gt;&#x3D; 0
vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b)
&#123;
    vector&lt;int&gt; C;

    int t &#x3D; 0;
    for (int i &#x3D; 0; i &lt; A.size() || t; i ++ )
    &#123;
        if (i &lt; A.size()) t +&#x3D; A[i] * b;
        C.push_back(t % 10);
        t &#x2F;&#x3D; 10;
    &#125;

    while (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();

    return C;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p><pre class="line-numbers language-java" data-language="java"><code class="language-java">
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">mul</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token class-name">A</span><span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token class-name">C</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		
	<span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>	
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">A</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> temp <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token class-name">A</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			temp <span class="token operator">+=</span> <span class="token class-name">A</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">*</span> b<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token class-name">C</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>temp <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		temp <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>	
	<span class="token punctuation">&#125;</span>		
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token class-name">C</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token class-name">C</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">C</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token class-name">C</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">C</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token class-name">C</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token class-name">C</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>	
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">getList</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>num <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>num <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		num <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> list<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">123456</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">654</span><span class="token punctuation">;</span>
	<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token class-name">A</span> <span class="token operator">=</span> <span class="token function">getList</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token class-name">B</span> <span class="token operator">=</span> <span class="token function">getList</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token class-name">C</span> <span class="token operator">=</span> <span class="token function">mul</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">,</span> <span class="token number">654</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="高精度除以低精度"><a class="anchor" href="#高精度除以低精度">#</a> 高精度除以低精度</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
&#x2F;&#x2F; A &#x2F; b &#x3D; C ... r, A &gt;&#x3D; 0, b &gt; 0
vector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)
&#123;
    vector&lt;int&gt; C;
    r &#x3D; 0;
    for (int i &#x3D; A.size() - 1; i &gt;&#x3D; 0; i -- )
    &#123;
        r &#x3D; r * 10 + A[i];
        C.push_back(r &#x2F; b);
        r %&#x3D; b;
    &#125;
    reverse(C.begin(), C.end());
    while (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();
    return C;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p><pre class="line-numbers language-java" data-language="java"><code class="language-java">
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">div</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token class-name">A</span><span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token class-name">C</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token class-name">A</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		r <span class="token operator">=</span> r <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token class-name">A</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">C</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>r <span class="token operator">/</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
		r <span class="token operator">%=</span> b<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token class-name">C</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token class-name">C</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token class-name">C</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">C</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token class-name">C</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">C</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
       <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token class-name">C</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token class-name">C</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">getList</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>num <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>num <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		num <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> list<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">123456</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">654</span><span class="token punctuation">;</span>
	<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token class-name">A</span> <span class="token operator">=</span> <span class="token function">getList</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token class-name">B</span> <span class="token operator">=</span> <span class="token function">getList</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token class-name">C</span> <span class="token operator">=</span> <span class="token function">div</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">,</span> <span class="token number">654</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="一维前缀和"><a class="anchor" href="#一维前缀和">#</a> 一维前缀和</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
&#x2F;&#x2F; 求区间3-5的前缀和，相当于1-5区间的前缀和减去1-2区间的前缀和
S[i] &#x3D; a[1] + a[2] + ... a[i]
a[l] + ... + a[r] &#x3D; S[r] - S[l - 1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="二维前缀和"><a class="anchor" href="#二维前缀和">#</a> 二维前缀和</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
S[i, j] &#x3D; 第i行j列格子左上部分所有元素的和
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="一维差分"><a class="anchor" href="#一维差分">#</a> 一维差分</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
给区间[l, r]中的每个数加上c：B[l] +&#x3D; c, B[r + 1] -&#x3D; c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h3 id="二维差分"><a class="anchor" href="#二维差分">#</a> 二维差分</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] +&#x3D; c, S[x2 + 1, y1] -&#x3D; c, S[x1, y2 + 1] -&#x3D; c, S[x2 + 1, y2 + 1] +&#x3D; c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><h3 id="位运算"><a class="anchor" href="#位运算">#</a> 位运算</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
求n的第k位数字: n &gt;&gt; k &amp; 1
返回n的最后一位1：lowbit(n) &#x3D; n &amp; -n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><h3 id="双指针算法"><a class="anchor" href="#双指针算法">#</a> 双指针算法</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
for (int i &#x3D; 0, j &#x3D; 0; i &lt; n; i ++ )
&#123;
    while (j &lt; i &amp;&amp; check(i, j)) j ++ ;

    &#x2F;&#x2F; 具体问题的逻辑
&#125;
常见问题分类：
    (1) 对于一个序列，用两个指针维护一段区间
    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="离散化"><a class="anchor" href="#离散化">#</a> 离散化</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
vector&lt;int&gt; alls; &#x2F;&#x2F; 存储所有待离散化的值
sort(alls.begin(), alls.end()); &#x2F;&#x2F; 将所有值排序
alls.erase(unique(alls.begin(), alls.end()), alls.end());   &#x2F;&#x2F; 去掉重复元素

&#x2F;&#x2F; 二分求出x对应的离散化的值
int find(int x) &#x2F;&#x2F; 找到第一个大于等于x的位置
&#123;
    int l &#x3D; 0, r &#x3D; alls.size() - 1;
    while (l &lt; r)
    &#123;
        int mid &#x3D; l + r &gt;&gt; 1;
        if (alls[mid] &gt;&#x3D; x) r &#x3D; mid;
        else l &#x3D; mid + 1;
    &#125;
    return r + 1; &#x2F;&#x2F; 映射到1, 2, ...n
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="区间合并"><a class="anchor" href="#区间合并">#</a> 区间合并</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
&#x2F;&#x2F; 将所有存在交集的区间合并
void merge(vector&lt;PII&gt; &amp;segs)
&#123;
    vector&lt;PII&gt; res;

    sort(segs.begin(), segs.end());

    int st &#x3D; -2e9, ed &#x3D; -2e9;
    for (auto seg : segs)
        if (ed &lt; seg.first)
        &#123;
            if (st !&#x3D; -2e9) res.push_back(&#123;st, ed&#125;);
            st &#x3D; seg.first, ed &#x3D; seg.second;
        &#125;
        else ed &#x3D; max(ed, seg.second);

    if (st !&#x3D; -2e9) res.push_back(&#123;st, ed&#125;);

    segs &#x3D; res;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="第二章-数据结构"><a class="anchor" href="#第二章-数据结构">#</a> 第二章 数据结构</h2><h3 id="单链表"><a class="anchor" href="#单链表">#</a> 单链表</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
&#x2F;&#x2F; head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点
int head, e[N], ne[N], idx;

&#x2F;&#x2F; 初始化
void init()
&#123;
    head &#x3D; -1;
    idx &#x3D; 0;
&#125;

&#x2F;&#x2F; 在链表头插入一个数a
void insert(int a)
&#123;
    e[idx] &#x3D; a, ne[idx] &#x3D; head, head &#x3D; idx ++ ;
&#125;

&#x2F;&#x2F; 将头结点删除，需要保证头结点存在
void remove()
&#123;
    head &#x3D; ne[head];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="双链表"><a class="anchor" href="#双链表">#</a> 双链表</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
&#x2F;&#x2F; e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点
int e[N], l[N], r[N], idx;

&#x2F;&#x2F; 初始化
void init()
&#123;
    &#x2F;&#x2F;0是左端点，1是右端点
    r[0] &#x3D; 1, l[1] &#x3D; 0;
    idx &#x3D; 2;
&#125;

&#x2F;&#x2F; 在节点a的右边插入一个数x
void insert(int a, int x)
&#123;
    e[idx] &#x3D; x;
    l[idx] &#x3D; a, r[idx] &#x3D; r[a];
    l[r[a]] &#x3D; idx, r[a] &#x3D; idx ++ ;
&#125;

&#x2F;&#x2F; 删除节点a
void remove(int a)
&#123;
    l[r[a]] &#x3D; l[a];
    r[l[a]] &#x3D; r[a];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="栈"><a class="anchor" href="#栈">#</a> 栈</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
&#x2F;&#x2F; tt表示栈顶
int stk[N], tt &#x3D; 0;

&#x2F;&#x2F; 向栈顶插入一个数
stk[ ++ tt] &#x3D; x;

&#x2F;&#x2F; 从栈顶弹出一个数
tt -- ;

&#x2F;&#x2F; 栈顶的值
stk[tt];

&#x2F;&#x2F; 判断栈是否为空
if (tt &gt; 0)
&#123;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="普通队列"><a class="anchor" href="#普通队列">#</a> 普通队列</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
&#x2F;&#x2F; hh 表示队头，tt表示队尾
int q[N], hh &#x3D; 0, tt &#x3D; -1;

&#x2F;&#x2F; 向队尾插入一个数
q[ ++ tt] &#x3D; x;

&#x2F;&#x2F; 从队头弹出一个数
hh ++ ;

&#x2F;&#x2F; 队头的值
q[hh];

&#x2F;&#x2F; 判断队列是否为空
if (hh &lt;&#x3D; tt)
&#123;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="循环队列"><a class="anchor" href="#循环队列">#</a> 循环队列</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
&#x2F;&#x2F; hh 表示队头，tt表示队尾的后一个位置
int q[N], hh &#x3D; 0, tt &#x3D; 0;

&#x2F;&#x2F; 向队尾插入一个数
q[tt ++ ] &#x3D; x;
if (tt &#x3D;&#x3D; N) tt &#x3D; 0;

&#x2F;&#x2F; 从队头弹出一个数
hh ++ ;
if (hh &#x3D;&#x3D; N) hh &#x3D; 0;

&#x2F;&#x2F; 队头的值
q[hh];

&#x2F;&#x2F; 判断队列是否为空
if (hh !&#x3D; tt)
&#123;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="单调栈"><a class="anchor" href="#单调栈">#</a> 单调栈</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
常见模型：找出每个数左边离它最近的比它大&#x2F;小的数
int tt &#x3D; 0;
for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )
&#123;
    while (tt &amp;&amp; check(stk[tt], i)) tt -- ;
    stk[ ++ tt] &#x3D; i;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="单调队列"><a class="anchor" href="#单调队列">#</a> 单调队列</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
常见模型：找出滑动窗口中的最大值&#x2F;最小值
int hh &#x3D; 0, tt &#x3D; -1;
for (int i &#x3D; 0; i &lt; n; i ++ )
&#123;
    while (hh &lt;&#x3D; tt &amp;&amp; check_out(q[hh])) hh ++ ;  &#x2F;&#x2F; 判断队头是否滑出窗口
    while (hh &lt;&#x3D; tt &amp;&amp; check(q[tt], i)) tt -- ;
    q[ ++ tt] &#x3D; i;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="kmp"><a class="anchor" href="#kmp">#</a> KMP</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
&#x2F;&#x2F; s[]是长文本，p[]是模式串，n是s的长度，m是p的长度
求模式串的Next数组：
for (int i &#x3D; 2, j &#x3D; 0; i &lt;&#x3D; m; i ++ )
&#123;
    while (j &amp;&amp; p[i] !&#x3D; p[j + 1]) j &#x3D; ne[j];
    if (p[i] &#x3D;&#x3D; p[j + 1]) j ++ ;
    ne[i] &#x3D; j;
&#125;

&#x2F;&#x2F; 匹配
for (int i &#x3D; 1, j &#x3D; 0; i &lt;&#x3D; n; i ++ )
&#123;
    while (j &amp;&amp; s[i] !&#x3D; p[j + 1]) j &#x3D; ne[j];
    if (s[i] &#x3D;&#x3D; p[j + 1]) j ++ ;
    if (j &#x3D;&#x3D; m)
    &#123;
        j &#x3D; ne[j];
        &#x2F;&#x2F; 匹配成功后的逻辑
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="trie树"><a class="anchor" href="#trie树">#</a> Trie 树</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
int son[N][26], cnt[N], idx;
&#x2F;&#x2F; 0号点既是根节点，又是空节点
&#x2F;&#x2F; son[][]存储树中每个节点的子节点
&#x2F;&#x2F; cnt[]存储以每个节点结尾的单词数量

&#x2F;&#x2F; 插入一个字符串
void insert(char *str)
&#123;
    int p &#x3D; 0;
    for (int i &#x3D; 0; str[i]; i ++ )
    &#123;
        int u &#x3D; str[i] - &#39;a&#39;;
        if (!son[p][u]) son[p][u] &#x3D; ++ idx;
        p &#x3D; son[p][u];
    &#125;
    cnt[p] ++ ;
&#125;

&#x2F;&#x2F; 查询字符串出现的次数
int query(char *str)
&#123;
    int p &#x3D; 0;
    for (int i &#x3D; 0; str[i]; i ++ )
    &#123;
        int u &#x3D; str[i] - &#39;a&#39;;
        if (!son[p][u]) return 0;
        p &#x3D; son[p][u];
    &#125;
    return cnt[p];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="朴素并查集"><a class="anchor" href="#朴素并查集">#</a> 朴素并查集</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
int p[N]; &#x2F;&#x2F;存储每个点的祖宗节点

&#x2F;&#x2F; 返回x的祖宗节点
int find(int x) &#123;
    if (p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);
    return p[x];
&#125;

&#x2F;&#x2F; 初始化，假定节点编号是1~n
for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) p[i] &#x3D; i;

&#x2F;&#x2F; 合并a和b所在的两个集合：
p[find(a)] &#x3D; find(b);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="维护size的并查集"><a class="anchor" href="#维护size的并查集">#</a> 维护 size 的并查集</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
int p[N], size[N];
    &#x2F;&#x2F;p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量

&#x2F;&#x2F; 返回x的祖宗节点
int find(int x) &#123;
    if (p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);
    return p[x];
&#125;

&#x2F;&#x2F; 初始化，假定节点编号是1~n
for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) &#123;
    p[i] &#x3D; i;
    size[i] &#x3D; 1;
&#125;

&#x2F;&#x2F; 合并a和b所在的两个集合：
size[find(b)] +&#x3D; size[find(a)];
p[find(a)] &#x3D; find(b);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="维护到祖宗节点距离的并查集"><a class="anchor" href="#维护到祖宗节点距离的并查集">#</a> 维护到祖宗节点距离的并查集</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
int p[N], d[N];
&#x2F;&#x2F;p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离

&#x2F;&#x2F; 返回x的祖宗节点
int find(int x) &#123;
	if (p[x] !&#x3D; x) &#123;
        int u &#x3D; find(p[x]);
        d[x] +&#x3D; d[p[x]];
        p[x] &#x3D; u;
	&#125;
	return p[x];
&#125;

&#x2F;&#x2F; 初始化，假定节点编号是1~n
for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) &#123;
    p[i] &#x3D; i;
    d[i] &#x3D; 0;
&#125;

&#x2F;&#x2F; 合并a和b所在的两个集合：
p[find(a)] &#x3D; find(b);
d[find(a)] &#x3D; distance; &#x2F;&#x2F; 根据具体问题，初始化find(a)的偏移量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="堆"><a class="anchor" href="#堆">#</a> 堆</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
&#x2F;&#x2F; h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1
&#x2F;&#x2F; ph[k]存储第k个插入的点在堆中的位置
&#x2F;&#x2F; hp[k]存储堆中下标是k的点是第几个插入的
int h[N], ph[N], hp[N], size;

&#x2F;&#x2F; 交换两个点，及其映射关系
void heap_swap(int a, int b)
&#123;
    swap(ph[hp[a]],ph[hp[b]]);
    swap(hp[a], hp[b]);
    swap(h[a], h[b]);
&#125;

void down(int u)
&#123;
    int t &#x3D; u;
    if (u * 2 &lt;&#x3D; size &amp;&amp; h[u * 2] &lt; h[t]) t &#x3D; u * 2;
    if (u * 2 + 1 &lt;&#x3D; size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t &#x3D; u * 2 + 1;
    if (u !&#x3D; t)
    &#123;
        heap_swap(u, t);
        down(t);
    &#125;
&#125;

void up(int u)
&#123;
    while (u &#x2F; 2 &amp;&amp; h[u] &lt; h[u &#x2F; 2])
    &#123;
        heap_swap(u, u &#x2F; 2);
        u &gt;&gt;&#x3D; 1;
    &#125;
&#125;

&#x2F;&#x2F; O(n)建堆
for (int i &#x3D; n &#x2F; 2; i; i -- ) down(i);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="一般哈希拉链法"><a class="anchor" href="#一般哈希拉链法">#</a> 一般哈希：拉链法</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
int h[N], e[N], ne[N], idx;

   &#x2F;&#x2F; 向哈希表中插入一个数
   void insert(int x)
   &#123;
       int k &#x3D; (x % N + N) % N;
       e[idx] &#x3D; x;
       ne[idx] &#x3D; h[k];
       h[k] &#x3D; idx ++ ;
   &#125;

   &#x2F;&#x2F; 在哈希表中查询某个数是否存在
   bool find(int x)
   &#123;
       int k &#x3D; (x % N + N) % N;
       for (int i &#x3D; h[k]; i !&#x3D; -1; i &#x3D; ne[i])
           if (e[i] &#x3D;&#x3D; x)
               return true;

       return false;
   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="一般哈希开放寻址法"><a class="anchor" href="#一般哈希开放寻址法">#</a> 一般哈希：开放寻址法</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
int h[N];

   &#x2F;&#x2F; 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置
   int find(int x)
   &#123;
       int t &#x3D; (x % N + N) % N;
       while (h[t] !&#x3D; null &amp;&amp; h[t] !&#x3D; x)
       &#123;
           t ++ ;
           if (t &#x3D;&#x3D; N) t &#x3D; 0;
       &#125;
       return t;
   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="字符串哈希"><a class="anchor" href="#字符串哈希">#</a> 字符串哈希</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低
小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果

typedef unsigned long long ULL;
ULL h[N], p[N]; &#x2F;&#x2F; h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64

&#x2F;&#x2F; 初始化
p[0] &#x3D; 1;
for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )
&#123;
    h[i] &#x3D; h[i - 1] * P + str[i];
    p[i] &#x3D; p[i - 1] * P;
&#125;

&#x2F;&#x2F; 计算子串 str[l ~ r] 的哈希值
ULL get(int l, int r)
&#123;
    return h[r] - h[l - 1] * p[r - l + 1];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="c-stl"><a class="anchor" href="#c-stl">#</a> c++ STL</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
vector, 变长数组，倍增的思想
    size()  返回元素个数
    empty()  返回是否为空
    clear()  清空
    front()&#x2F;back()
    push_back()&#x2F;pop_back()
    begin()&#x2F;end()
    []
    支持比较运算，按字典序

pair&lt;int, int&gt;
    first, 第一个元素
    second, 第二个元素
    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）

string，字符串
    size()&#x2F;length()  返回字符串长度
    empty()
    clear()
    substr(起始下标，(子串长度))  返回子串
    c_str()  返回字符串所在字符数组的起始地址

queue, 队列
    size()
    empty()
    push()  向队尾插入一个元素
    front()  返回队头元素
    back()  返回队尾元素
    pop()  弹出队头元素

priority_queue, 优先队列，默认是大根堆
    size()
    empty()
    push()  插入一个元素
    top()  返回堆顶元素
    pop()  弹出堆顶元素
    定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;

stack, 栈
    size()
    empty()
    push()  向栈顶插入一个元素
    top()  返回栈顶元素
    pop()  弹出栈顶元素

deque, 双端队列
    size()
    empty()
    clear()
    front()&#x2F;back()
    push_back()&#x2F;pop_back()
    push_front()&#x2F;pop_front()
    begin()&#x2F;end()
    []

set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列
    size()
    empty()
    clear()
    begin()&#x2F;end()
    ++, -- 返回前驱和后继，时间复杂度 O(logn)

    set&#x2F;multiset
        insert()  插入一个数
        find()  查找一个数
        count()  返回某一个数的个数
        erase()
            (1) 输入是一个数x，删除所有x   O(k + logn)
            (2) 输入一个迭代器，删除这个迭代器
        lower_bound()&#x2F;upper_bound()
            lower_bound(x)  返回大于等于x的最小的数的迭代器
            upper_bound(x)  返回大于x的最小的数的迭代器
    map&#x2F;multimap
        insert()  插入的数是一个pair
        erase()  输入的参数是pair或者迭代器
        find()
        []  注意multimap不支持此操作。 时间复杂度是 O(logn)
        lower_bound()&#x2F;upper_bound()

unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表
    和上面类似，增删改查的时间复杂度是 O(1)
    不支持 lower_bound()&#x2F;upper_bound()， 迭代器的++，--

bitset, 圧位
    bitset&lt;10000&gt; s;
    ~, &amp;, |, ^
    &gt;&gt;, &lt;&lt;
    &#x3D;&#x3D;, !&#x3D;
    []

    count()  返回有多少个1

    any()  判断是否至少有一个1
    none()  判断是否全为0

    set()  把所有位置成1
    set(k, v)  将第k位变成v
    reset()  把所有位变成0
    flip()  等价于~
    flip(k) 把第k位取反<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="第三章-搜索与图论"><a class="anchor" href="#第三章-搜索与图论">#</a> 第三章 搜索与图论</h2><h3 id="树与图的存储"><a class="anchor" href="#树与图的存储">#</a> 树与图的存储</h3><p>​ 树是一种特殊的图，与图的存储方式相同。</p><p>​ 对于无向图中的边 ab，存储两条有向边 a-&gt;b， b-&gt;a。<br>​ 因此我们可以只考虑有向图的存储。</p><p>​ (1) 邻接矩阵：g [a][b] 存储边 a-&gt;b</p><p>​ (2) 邻接表</p><h3 id="邻接表"><a class="anchor" href="#邻接表">#</a> 邻接表</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
&#x2F;&#x2F; 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点
int h[N], e[N], ne[N], idx;

&#x2F;&#x2F; 添加一条边a-&gt;b
void add(int a, int b)
&#123;
    e[idx] &#x3D; b, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;
&#125;

&#x2F;&#x2F; 初始化
idx &#x3D; 0;
memset(h, -1, sizeof h);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="树与图的遍历"><a class="anchor" href="#树与图的遍历">#</a> 树与图的遍历</h3><p>​ 时间复杂度 <code>O(n+m)</code> ， <code>n</code> 表示点数， <code>m</code> 表示边数</p><h4 id="深度优先遍历"><a class="anchor" href="#深度优先遍历">#</a> 深度优先遍历</h4><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
int dfs(int u)
&#123;
    st[u] &#x3D; true; &#x2F;&#x2F; st[u] 表示点u已经被遍历过

    for (int i &#x3D; h[u]; i !&#x3D; -1; i &#x3D; ne[i])
    &#123;
        int j &#x3D; e[i];
        if (!st[j]) dfs(j);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h4 id="宽度优先遍历"><a class="anchor" href="#宽度优先遍历">#</a> 宽度优先遍历</h4><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
queue&lt;int&gt; q;
st[1] &#x3D; true; &#x2F;&#x2F; 表示1号点已经被遍历过
q.push(1);

while (q.size())
&#123;
    int t &#x3D; q.front();
    q.pop();

    for (int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])
    &#123;
        int j &#x3D; e[i];
        if (!st[j])
        &#123;
            st[j] &#x3D; true; &#x2F;&#x2F; 表示点j已经被遍历过
            q.push(j);
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="拓扑排序"><a class="anchor" href="#拓扑排序">#</a> 拓扑排序</h3><p>​ 时间复杂度 <code>O(n+m)</code> ， <code>n</code> 表示点数， <code>m</code> 表示边数</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
bool topsort()
&#123;
    int hh &#x3D; 0, tt &#x3D; -1;

    &#x2F;&#x2F; d[i] 存储点i的入度
    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )
        if (!d[i])
            q[ ++ tt] &#x3D; i;

    while (hh &lt;&#x3D; tt)
    &#123;
        int t &#x3D; q[hh ++ ];

        for (int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])
        &#123;
            int j &#x3D; e[i];
            if (-- d[j] &#x3D;&#x3D; 0)
                q[ ++ tt] &#x3D; j;
        &#125;
    &#125;

    &#x2F;&#x2F; 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。
    return tt &#x3D;&#x3D; n - 1;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="朴素dijkstra算法"><a class="anchor" href="#朴素dijkstra算法">#</a> 朴素 dijkstra 算法</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
int g[N][N];  &#x2F;&#x2F; 存储每条边
int dist[N];  &#x2F;&#x2F; 存储1号点到每个点的最短距离
bool st[N];   &#x2F;&#x2F; 存储每个点的最短路是否已经确定

&#x2F;&#x2F; 求1号点到n号点的最短路，如果不存在则返回-1
int dijkstra()
&#123;
    memset(dist, 0x3f, sizeof dist);
    dist[1] &#x3D; 0;

    for (int i &#x3D; 0; i &lt; n - 1; i ++ )
    &#123;
        int t &#x3D; -1;     &#x2F;&#x2F; 在还未确定最短路的点中，寻找距离最小的点
        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )
            if (!st[j] &amp;&amp; (t &#x3D;&#x3D; -1 || dist[t] &gt; dist[j]))
                t &#x3D; j;

        &#x2F;&#x2F; 用t更新其他点的距离
        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )
            dist[j] &#x3D; min(dist[j], dist[t] + g[t][j]);

        st[t] &#x3D; true;
    &#125;

    if (dist[n] &#x3D;&#x3D; 0x3f3f3f3f) return -1;
    return dist[n];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="堆优化版dijkstra"><a class="anchor" href="#堆优化版dijkstra">#</a> 堆优化版 dijkstra</h3><p>​ 时间复杂度 <code>O(mlogn)</code> ， <code>n</code> 表示点数， <code>m</code> 表示边数</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
typedef pair&lt;int, int&gt; PII;

int n;      &#x2F;&#x2F; 点的数量
int h[N], w[N], e[N], ne[N], idx;       &#x2F;&#x2F; 邻接表存储所有边
int dist[N];        &#x2F;&#x2F; 存储所有点到1号点的距离
bool st[N];     &#x2F;&#x2F; 存储每个点的最短距离是否已确定

&#x2F;&#x2F; 求1号点到n号点的最短距离，如果不存在，则返回-1
int dijkstra()
&#123;
    memset(dist, 0x3f, sizeof dist);
    dist[1] &#x3D; 0;
    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;
    heap.push(&#123;0, 1&#125;);      &#x2F;&#x2F; first存储距离，second存储节点编号

    while (heap.size())
    &#123;
        auto t &#x3D; heap.top();
        heap.pop();

        int ver &#x3D; t.second, distance &#x3D; t.first;

        if (st[ver]) continue;
        st[ver] &#x3D; true;

        for (int i &#x3D; h[ver]; i !&#x3D; -1; i &#x3D; ne[i])
        &#123;
            int j &#x3D; e[i];
            if (dist[j] &gt; distance + w[i])
            &#123;
                dist[j] &#x3D; distance + w[i];
                heap.push(&#123;dist[j], j&#125;);
            &#125;
        &#125;
    &#125;

    if (dist[n] &#x3D;&#x3D; 0x3f3f3f3f) return -1;
    return dist[n];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="bellman-ford算法"><a class="anchor" href="#bellman-ford算法">#</a> Bellman-Ford 算法</h3><p>​ 时间复杂度 <code>O(nm)</code> ， <code>n</code> 表示点数， <code>m</code> 表示边数。注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题。</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
int n, m;       &#x2F;&#x2F; n表示点数，m表示边数
int dist[N];        &#x2F;&#x2F; dist[x]存储1到x的最短路距离

struct Edge     &#x2F;&#x2F; 边，a表示出点，b表示入点，w表示边的权重
&#123;
    int a, b, w;
&#125; edges[M];

&#x2F;&#x2F; 求1到n的最短路距离，如果无法从1走到n，则返回-1。
int bellman_ford()
&#123;
    memset(dist, 0x3f, sizeof dist);
    dist[1] &#x3D; 0;

    &#x2F;&#x2F; 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。
    for (int i &#x3D; 0; i &lt; n; i ++ )
    &#123;
        for (int j &#x3D; 0; j &lt; m; j ++ )
        &#123;
            int a &#x3D; edges[j].a, b &#x3D; edges[j].b, w &#x3D; edges[j].w;
            if (dist[b] &gt; dist[a] + w)
                dist[b] &#x3D; dist[a] + w;
        &#125;
    &#125;

    if (dist[n] &gt; 0x3f3f3f3f &#x2F; 2) return -1;
    return dist[n];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="spfa-算法队列优化的bellman-ford算法"><a class="anchor" href="#spfa-算法队列优化的bellman-ford算法">#</a> spfa 算法（队列优化的 Bellman-Ford 算法）</h3><p>​ 时间复杂度 平均情况下 <code>O(m)</code> ，最坏情况下 O (nm)，n 表示点数，m 表示边数</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
int n;      &#x2F;&#x2F; 总点数
int h[N], w[N], e[N], ne[N], idx;       &#x2F;&#x2F; 邻接表存储所有边
int dist[N];        &#x2F;&#x2F; 存储每个点到1号点的最短距离
bool st[N];     &#x2F;&#x2F; 存储每个点是否在队列中

&#x2F;&#x2F; 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1
int spfa()
&#123;
    memset(dist, 0x3f, sizeof dist);
    dist[1] &#x3D; 0;

    queue&lt;int&gt; q;
    q.push(1);
    st[1] &#x3D; true;

    while (q.size())
    &#123;
        auto t &#x3D; q.front();
        q.pop();

        st[t] &#x3D; false;

        for (int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])
        &#123;
            int j &#x3D; e[i];
            if (dist[j] &gt; dist[t] + w[i])
            &#123;
                dist[j] &#x3D; dist[t] + w[i];
                if (!st[j])     &#x2F;&#x2F; 如果队列中已存在j，则不需要将j重复插入
                &#123;
                    q.push(j);
                    st[j] &#x3D; true;
                &#125;
            &#125;
        &#125;
    &#125;

    if (dist[n] &#x3D;&#x3D; 0x3f3f3f3f) return -1;
    return dist[n];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="spfa判断图中是否存在负环"><a class="anchor" href="#spfa判断图中是否存在负环">#</a> spfa 判断图中是否存在负环</h3><p>​ 时间复杂度是 <code>O(nm)</code> ， <code>n</code> 表示点数， <code>m</code> 表示边数</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
int n;      &#x2F;&#x2F; 总点数
int h[N], w[N], e[N], ne[N], idx;       &#x2F;&#x2F; 邻接表存储所有边
int dist[N], cnt[N];        &#x2F;&#x2F; dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数
bool st[N];     &#x2F;&#x2F; 存储每个点是否在队列中

&#x2F;&#x2F; 如果存在负环，则返回true，否则返回false。
bool spfa()
&#123;
    &#x2F;&#x2F; 不需要初始化dist数组
    &#x2F;&#x2F; 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。

    queue&lt;int&gt; q;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )
    &#123;
        q.push(i);
        st[i] &#x3D; true;
    &#125;

    while (q.size())
    &#123;
        auto t &#x3D; q.front();
        q.pop();

        st[t] &#x3D; false;

        for (int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])
        &#123;
            int j &#x3D; e[i];
            if (dist[j] &gt; dist[t] + w[i])
            &#123;
                dist[j] &#x3D; dist[t] + w[i];
                cnt[j] &#x3D; cnt[t] + 1;
                if (cnt[j] &gt;&#x3D; n) return true;       &#x2F;&#x2F; 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环
                if (!st[j])
                &#123;
                    q.push(j);
                    st[j] &#x3D; true;
                &#125;
            &#125;
        &#125;
    &#125;

    return false;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="floyd算法"><a class="anchor" href="#floyd算法">#</a> floyd 算法</h3><p>​ 时间复杂度是 <code>O(n3)</code> ， <code>n</code> 表示点数</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
初始化：
    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )
        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )
            if (i &#x3D;&#x3D; j) d[i][j] &#x3D; 0;
            else d[i][j] &#x3D; INF;

&#x2F;&#x2F; 算法结束后，d[a][b]表示a到b的最短距离
void floyd()
&#123;
    for (int k &#x3D; 1; k &lt;&#x3D; n; k ++ )
        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )
            for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )
                d[i][j] &#x3D; min(d[i][j], d[i][k] + d[k][j]);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="朴素版prim算法"><a class="anchor" href="#朴素版prim算法">#</a> 朴素版 prim 算法</h3><p>​ 时间复杂度是 <code>O(n2+m)</code> ， <code>n</code> 表示点数， <code>m</code> 表示边数</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
int n;      &#x2F;&#x2F; n表示点数
int g[N][N];        &#x2F;&#x2F; 邻接矩阵，存储所有边
int dist[N];        &#x2F;&#x2F; 存储其他点到当前最小生成树的距离
bool st[N];     &#x2F;&#x2F; 存储每个点是否已经在生成树中


&#x2F;&#x2F; 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和
int prim()
&#123;
    memset(dist, 0x3f, sizeof dist);

    int res &#x3D; 0;
    for (int i &#x3D; 0; i &lt; n; i ++ )
    &#123;
        int t &#x3D; -1;
        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )
            if (!st[j] &amp;&amp; (t &#x3D;&#x3D; -1 || dist[t] &gt; dist[j]))
                t &#x3D; j;

        if (i &amp;&amp; dist[t] &#x3D;&#x3D; INF) return INF;

        if (i) res +&#x3D; dist[t];
        st[t] &#x3D; true;

        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ ) dist[j] &#x3D; min(dist[j], g[t][j]);
    &#125;

    return res;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="kruskal算法"><a class="anchor" href="#kruskal算法">#</a> Kruskal 算法</h3><p>​ 时间复杂度是 <code>O(mlogm)</code> ， <code>n</code> 表示点数， <code>m</code> 表示边数</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
int n, m;       &#x2F;&#x2F; n是点数，m是边数
int p[N];       &#x2F;&#x2F; 并查集的父节点数组

struct Edge     &#x2F;&#x2F; 存储边
&#123;
    int a, b, w;

    bool operator&lt; (const Edge &amp;W)const
    &#123;
        return w &lt; W.w;
    &#125;
&#125;edges[M];

int find(int x)     &#x2F;&#x2F; 并查集核心操作
&#123;
    if (p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);
    return p[x];
&#125;

int kruskal()
&#123;
    sort(edges, edges + m);

    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) p[i] &#x3D; i;    &#x2F;&#x2F; 初始化并查集

    int res &#x3D; 0, cnt &#x3D; 0;
    for (int i &#x3D; 0; i &lt; m; i ++ )
    &#123;
        int a &#x3D; edges[i].a, b &#x3D; edges[i].b, w &#x3D; edges[i].w;

        a &#x3D; find(a), b &#x3D; find(b);
        if (a !&#x3D; b)     &#x2F;&#x2F; 如果两个连通块不连通，则将这两个连通块合并
        &#123;
            p[a] &#x3D; b;
            res +&#x3D; w;
            cnt ++ ;
        &#125;
    &#125;

    if (cnt &lt; n - 1) return INF;
    return res;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="染色法判别二分图"><a class="anchor" href="#染色法判别二分图">#</a> 染色法判别二分图</h3><p>​ 时间复杂度是 <code>O(n+m)</code> ， <code>n</code> 表示点数， <code>m</code> 表示边数</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
int n;      &#x2F;&#x2F; n表示点数
int h[N], e[M], ne[M], idx;     &#x2F;&#x2F; 邻接表存储图
int color[N];       &#x2F;&#x2F; 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色

&#x2F;&#x2F; 参数：u表示当前节点，c表示当前点的颜色
bool dfs(int u, int c)
&#123;
    color[u] &#x3D; c;
    for (int i &#x3D; h[u]; i !&#x3D; -1; i &#x3D; ne[i])
    &#123;
        int j &#x3D; e[i];
        if (color[j] &#x3D;&#x3D; -1)
        &#123;
            if (!dfs(j, !c)) return false;
        &#125;
        else if (color[j] &#x3D;&#x3D; c) return false;
    &#125;

    return true;
&#125;

bool check()
&#123;
    memset(color, -1, sizeof color);
    bool flag &#x3D; true;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )
        if (color[i] &#x3D;&#x3D; -1)
            if (!dfs(i, 0))
            &#123;
                flag &#x3D; false;
                break;
            &#125;
    return flag;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="匈牙利算法"><a class="anchor" href="#匈牙利算法">#</a> 匈牙利算法</h3><p>​ 时间复杂度是 <code>O(nm)</code> , <code>n</code> 表示点数， <code>m</code> 表示边数</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
int n1, n2;     &#x2F;&#x2F; n1表示第一个集合中的点数，n2表示第二个集合中的点数
int h[N], e[M], ne[M], idx;     &#x2F;&#x2F; 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边
int match[N];       &#x2F;&#x2F; 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个
bool st[N];     &#x2F;&#x2F; 表示第二个集合中的每个点是否已经被遍历过

bool find(int x)
&#123;
    for (int i &#x3D; h[x]; i !&#x3D; -1; i &#x3D; ne[i])
    &#123;
        int j &#x3D; e[i];
        if (!st[j])
        &#123;
            st[j] &#x3D; true;
            if (match[j] &#x3D;&#x3D; 0 || find(match[j]))
            &#123;
                match[j] &#x3D; x;
                return true;
            &#125;
        &#125;
    &#125;

    return false;
&#125;

&#x2F;&#x2F; 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点
int res &#x3D; 0;
for (int i &#x3D; 1; i &lt;&#x3D; n1; i ++ )
&#123;
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="第四章-数学知识"><a class="anchor" href="#第四章-数学知识">#</a> 第四章 数学知识</h2><h3 id="试除法判定质数"><a class="anchor" href="#试除法判定质数">#</a> 试除法判定质数</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
bool is_prime(int x)
&#123;
    if (x &lt; 2) return false;
    for (int i &#x3D; 2; i &lt;&#x3D; x &#x2F; i; i ++ )
        if (x % i &#x3D;&#x3D; 0)
            return false;
    return true;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="试除法分解质因数"><a class="anchor" href="#试除法分解质因数">#</a> 试除法分解质因数</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
void divide(int x)
&#123;
    for (int i &#x3D; 2; i &lt;&#x3D; x &#x2F; i; i ++ )
        if (x % i &#x3D;&#x3D; 0)
        &#123;
            int s &#x3D; 0;
            while (x % i &#x3D;&#x3D; 0) x &#x2F;&#x3D; i, s ++ ;
            cout &lt;&lt; i &lt;&lt; &#39; &#39; &lt;&lt; s &lt;&lt; endl;
        &#125;
    if (x &gt; 1) cout &lt;&lt; x &lt;&lt; &#39; &#39; &lt;&lt; 1 &lt;&lt; endl;
    cout &lt;&lt; endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="朴素筛法求素数"><a class="anchor" href="#朴素筛法求素数">#</a> 朴素筛法求素数</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
int primes[N], cnt;     &#x2F;&#x2F; primes[]存储所有素数
bool st[N];         &#x2F;&#x2F; st[x]存储x是否被筛掉

void get_primes(int n)
&#123;
    for (int i &#x3D; 2; i &lt;&#x3D; n; i ++ )
    &#123;
        if (st[i]) continue;
        primes[cnt ++ ] &#x3D; i;
        for (int j &#x3D; i + i; j &lt;&#x3D; n; j +&#x3D; i)
            st[j] &#x3D; true;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="线性筛法求素数"><a class="anchor" href="#线性筛法求素数">#</a> 线性筛法求素数</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
int primes[N], cnt;     &#x2F;&#x2F; primes[]存储所有素数
bool st[N];         &#x2F;&#x2F; st[x]存储x是否被筛掉

void get_primes(int n)
&#123;
    for (int i &#x3D; 2; i &lt;&#x3D; n; i ++ )
    &#123;
        if (!st[i]) primes[cnt ++ ] &#x3D; i;
        for (int j &#x3D; 0; primes[j] &lt;&#x3D; n &#x2F; i; j ++ )
        &#123;
            st[primes[j] * i] &#x3D; true;
            if (i % primes[j] &#x3D;&#x3D; 0) break;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="试除法求所有约数"><a class="anchor" href="#试除法求所有约数">#</a> 试除法求所有约数</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
vector&lt;int&gt; get_divisors(int x)
&#123;
    vector&lt;int&gt; res;
    for (int i &#x3D; 1; i &lt;&#x3D; x &#x2F; i; i ++ )
        if (x % i &#x3D;&#x3D; 0)
        &#123;
            res.push_back(i);
            if (i !&#x3D; x &#x2F; i) res.push_back(x &#x2F; i);
        &#125;
    sort(res.begin(), res.end());
    return res;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="约数个数和约数之和"><a class="anchor" href="#约数个数和约数之和">#</a> 约数个数和约数之和</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
如果 N &#x3D; p1^c1 * p2^c2 * ... *pk^ck
约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1)
约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="欧几里得算法"><a class="anchor" href="#欧几里得算法">#</a> 欧几里得算法</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
int gcd(int a, int b)
&#123;
    return b ? gcd(b, a % b) : a;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="求欧拉函数"><a class="anchor" href="#求欧拉函数">#</a> 求欧拉函数</h3><p>​ 表示小于或等于 N 的正整数中与 N 互质的数的个数</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
int phi(int x)
&#123;
    int res &#x3D; x;
    for (int i &#x3D; 2; i &lt;&#x3D; x &#x2F; i; i ++ )
        if (x % i &#x3D;&#x3D; 0)
        &#123;
            res &#x3D; res &#x2F; i * (i - 1);
            while (x % i &#x3D;&#x3D; 0) x &#x2F;&#x3D; i;
        &#125;
    if (x &gt; 1) res &#x3D; res &#x2F; x * (x - 1);

    return res;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="筛法求欧拉函数"><a class="anchor" href="#筛法求欧拉函数">#</a> 筛法求欧拉函数</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
int primes[N], cnt;     &#x2F;&#x2F; primes[]存储所有素数
int euler[N];           &#x2F;&#x2F; 存储每个数的欧拉函数
bool st[N];         &#x2F;&#x2F; st[x]存储x是否被筛掉


void get_eulers(int n)
&#123;
    euler[1] &#x3D; 1;
    for (int i &#x3D; 2; i &lt;&#x3D; n; i ++ )
    &#123;
        if (!st[i])
        &#123;
            primes[cnt ++ ] &#x3D; i;
            euler[i] &#x3D; i - 1;
        &#125;
        for (int j &#x3D; 0; primes[j] &lt;&#x3D; n &#x2F; i; j ++ )
        &#123;
            int t &#x3D; primes[j] * i;
            st[t] &#x3D; true;
            if (i % primes[j] &#x3D;&#x3D; 0)
            &#123;
                euler[t] &#x3D; euler[i] * primes[j];
                break;
            &#125;
            euler[t] &#x3D; euler[i] * (primes[j] - 1);
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="快速幂"><a class="anchor" href="#快速幂">#</a> 快速幂</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
求 m^k mod p，时间复杂度 O(logk)。

int qmi(int m, int k, int p)
&#123;
    int res &#x3D; 1 % p, t &#x3D; m;
    while (k)
    &#123;
        if (k&amp;1) res &#x3D; res * t % p;
        t &#x3D; t * t % p;
        k &gt;&gt;&#x3D; 1;
    &#125;
    return res;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="扩展欧几里得算法"><a class="anchor" href="#扩展欧几里得算法">#</a> 扩展欧几里得算法</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
&#x2F;&#x2F; 求x, y，使得ax + by &#x3D; gcd(a, b)
int exgcd(int a, int b, int &amp;x, int &amp;y)
&#123;
    if (!b)
    &#123;
        x &#x3D; 1; y &#x3D; 0;
        return a;
    &#125;
    int d &#x3D; exgcd(b, a % b, y, x);
    y -&#x3D; (a&#x2F;b) * x;
    return d;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="高斯消元"><a class="anchor" href="#高斯消元">#</a> 高斯消元</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
&#x2F;&#x2F; a[N][N]是增广矩阵
int gauss()
&#123;
    int c, r;
    for (c &#x3D; 0, r &#x3D; 0; c &lt; n; c ++ )
    &#123;
        int t &#x3D; r;
        for (int i &#x3D; r; i &lt; n; i ++ )   &#x2F;&#x2F; 找到绝对值最大的行
            if (fabs(a[i][c]) &gt; fabs(a[t][c]))
                t &#x3D; i;

        if (fabs(a[t][c]) &lt; eps) continue;

        for (int i &#x3D; c; i &lt;&#x3D; n; i ++ ) swap(a[t][i], a[r][i]);      &#x2F;&#x2F; 将绝对值最大的行换到最顶端
        for (int i &#x3D; n; i &gt;&#x3D; c; i -- ) a[r][i] &#x2F;&#x3D; a[r][c];      &#x2F;&#x2F; 将当前行的首位变成1
        for (int i &#x3D; r + 1; i &lt; n; i ++ )       &#x2F;&#x2F; 用当前行将下面所有的列消成0
            if (fabs(a[i][c]) &gt; eps)
                for (int j &#x3D; n; j &gt;&#x3D; c; j -- )
                    a[i][j] -&#x3D; a[r][j] * a[i][c];

        r ++ ;
    &#125;

    if (r &lt; n)
    &#123;
        for (int i &#x3D; r; i &lt; n; i ++ )
            if (fabs(a[i][n]) &gt; eps)
                return 2; &#x2F;&#x2F; 无解
        return 1; &#x2F;&#x2F; 有无穷多组解
    &#125;

    for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i -- )
        for (int j &#x3D; i + 1; j &lt; n; j ++ )
            a[i][n] -&#x3D; a[i][j] * a[j][n];

    return 0; &#x2F;&#x2F; 有唯一解
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="递归法求组合数"><a class="anchor" href="#递归法求组合数">#</a> 递归法求组合数</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
&#x2F;&#x2F; c[a][b] 表示从a个苹果中选b个的方案数
for (int i &#x3D; 0; i &lt; N; i ++ )
    for (int j &#x3D; 0; j &lt;&#x3D; i; j ++ )
        if (!j) c[i][j] &#x3D; 1;
        else c[i][j] &#x3D; (c[i - 1][j] + c[i - 1][j - 1]) % mod;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="通过预处理逆元的方式求组合数"><a class="anchor" href="#通过预处理逆元的方式求组合数">#</a> 通过预处理逆元的方式求组合数</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N]
如果取模的数是质数，可以用费马小定理求逆元
int qmi(int a, int k, int p)    &#x2F;&#x2F; 快速幂模板
&#123;
    int res &#x3D; 1;
    while (k)
    &#123;
        if (k &amp; 1) res &#x3D; (LL)res * a % p;
        a &#x3D; (LL)a * a % p;
        k &gt;&gt;&#x3D; 1;
    &#125;
    return res;
&#125;

&#x2F;&#x2F; 预处理阶乘的余数和阶乘逆元的余数
fact[0] &#x3D; infact[0] &#x3D; 1;
for (int i &#x3D; 1; i &lt; N; i ++ )
&#123;
    fact[i] &#x3D; (LL)fact[i - 1] * i % mod;
    infact[i] &#x3D; (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="lucas定理"><a class="anchor" href="#lucas定理">#</a> Lucas 定理</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
若p是质数，则对于任意整数 1 &lt;&#x3D; m &lt;&#x3D; n，有：
    C(n, m) &#x3D; C(n % p, m % p) * C(n &#x2F; p, m &#x2F; p) (mod p)

int qmi(int a, int k, int p)  &#x2F;&#x2F; 快速幂模板
&#123;
    int res &#x3D; 1 % p;
    while (k)
    &#123;
        if (k &amp; 1) res &#x3D; (LL)res * a % p;
        a &#x3D; (LL)a * a % p;
        k &gt;&gt;&#x3D; 1;
    &#125;
    return res;
&#125;

int C(int a, int b, int p)  &#x2F;&#x2F; 通过定理求组合数C(a, b)
&#123;
    if (a &lt; b) return 0;

    LL x &#x3D; 1, y &#x3D; 1;  &#x2F;&#x2F; x是分子，y是分母
    for (int i &#x3D; a, j &#x3D; 1; j &lt;&#x3D; b; i --, j ++ )
    &#123;
        x &#x3D; (LL)x * i % p;
        y &#x3D; (LL) y * j % p;
    &#125;

    return x * (LL)qmi(y, p - 2, p) % p;
&#125;

int lucas(LL a, LL b, int p)
&#123;
    if (a &lt; p &amp;&amp; b &lt; p) return C(a, b, p);
    return (LL)C(a % p, b % p, p) * lucas(a &#x2F; p, b &#x2F; p, p) % p;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="分解质因数法求组合数"><a class="anchor" href="#分解质因数法求组合数">#</a> 分解质因数法求组合数</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：
    1. 筛法求出范围内的所有质数
    2. 通过 C(a, b) &#x3D; a! &#x2F; b! &#x2F; (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n &#x2F; p + n &#x2F; p^2 + n &#x2F; p^3 + ...
    3. 用高精度乘法将所有质因子相乘

int primes[N], cnt;     &#x2F;&#x2F; 存储所有质数
int sum[N];     &#x2F;&#x2F; 存储每个质数的次数
bool st[N];     &#x2F;&#x2F; 存储每个数是否已被筛掉


void get_primes(int n)      &#x2F;&#x2F; 线性筛法求素数
&#123;
    for (int i &#x3D; 2; i &lt;&#x3D; n; i ++ )
    &#123;
        if (!st[i]) primes[cnt ++ ] &#x3D; i;
        for (int j &#x3D; 0; primes[j] &lt;&#x3D; n &#x2F; i; j ++ )
        &#123;
            st[primes[j] * i] &#x3D; true;
            if (i % primes[j] &#x3D;&#x3D; 0) break;
        &#125;
    &#125;
&#125;


int get(int n, int p)       &#x2F;&#x2F; 求n！中的次数
&#123;
    int res &#x3D; 0;
    while (n)
    &#123;
        res +&#x3D; n &#x2F; p;
        n &#x2F;&#x3D; p;
    &#125;
    return res;
&#125;


vector&lt;int&gt; mul(vector&lt;int&gt; a, int b)       &#x2F;&#x2F; 高精度乘低精度模板
&#123;
    vector&lt;int&gt; c;
    int t &#x3D; 0;
    for (int i &#x3D; 0; i &lt; a.size(); i ++ )
    &#123;
        t +&#x3D; a[i] * b;
        c.push_back(t % 10);
        t &#x2F;&#x3D; 10;
    &#125;

    while (t)
    &#123;
        c.push_back(t % 10);
        t &#x2F;&#x3D; 10;
    &#125;

    return c;
&#125;

get_primes(a);  &#x2F;&#x2F; 预处理范围内的所有质数

for (int i &#x3D; 0; i &lt; cnt; i ++ )     &#x2F;&#x2F; 求每个质因数的次数
&#123;
    int p &#x3D; primes[i];
    sum[i] &#x3D; get(a, p) - get(b, p) - get(a - b, p);
&#125;

vector&lt;int&gt; res;
res.push_back(1);

for (int i &#x3D; 0; i &lt; cnt; i ++ )     &#x2F;&#x2F; 用高精度乘法将所有质因子相乘
    for (int j &#x3D; 0; j &lt; sum[i]; j ++ )
        res &#x3D; mul(res, primes[i]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="卡特兰数"><a class="anchor" href="#卡特兰数">#</a> 卡特兰数</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
给定n个0和n个1，它们按照某种顺序排成长度为2n的序列，满足任意前缀中0的个数都不少于1的个数的序列的数量为： Cat(n) &#x3D; C(2n, n) &#x2F; (n + 1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><div class="tags"><a href="/tags/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/" rel="tag"><i class="ic i-tag"></i> 学习心得</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-05-27 20:08:57" itemprop="dateModified" datetime="2023-05-27T20:08:57+08:00">2023-05-27</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="十月秋枫 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="十月秋枫 支付宝"><p>支付宝</p></div><div><img data-src="/images/friend.png" alt="十月秋枫 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>十月秋枫 <i class="ic i-at"><em>@</em></i>永远少年！</li><li class="link"><strong>本文链接：</strong> <a href="http://红叶.top/2023/05/23/computer-science/notes/%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/" title="算法板子">http://红叶.top/2023/05/23/computer-science/notes/算法代码模板/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/05/23/computer-science/notes/ACM%E3%80%81OI%E3%80%81IOI%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;t.mwm.moe&#x2F;ycy?373503" title="编程竞赛模式介绍"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 学习小记</span><h3>编程竞赛模式介绍</h3></a></div><div class="item right"><a href="/2023/05/23/computer-science/notes/%E6%8E%92%E5%BA%8F/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;t.mwm.moe&#x2F;ycy?86197" title="排序"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 学习小记</span><h3>排序</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.</span> <span class="toc-text">算法代码模板</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">第一章 基础算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">1.1.1.</span> <span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.1.2.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.3.</span> <span class="toc-text">整数二分算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.4.</span> <span class="toc-text">浮点数二分算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95"><span class="toc-number">1.1.5.</span> <span class="toc-text">高精度加法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95"><span class="toc-number">1.1.6.</span> <span class="toc-text">高精度减法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E4%BD%8E%E7%B2%BE%E5%BA%A6"><span class="toc-number">1.1.7.</span> <span class="toc-text">高精度乘低精度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E4%BB%A5%E4%BD%8E%E7%B2%BE%E5%BA%A6"><span class="toc-number">1.1.8.</span> <span class="toc-text">高精度除以低精度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">1.1.9.</span> <span class="toc-text">一维前缀和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">1.1.10.</span> <span class="toc-text">二维前缀和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E5%B7%AE%E5%88%86"><span class="toc-number">1.1.11.</span> <span class="toc-text">一维差分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86"><span class="toc-number">1.1.12.</span> <span class="toc-text">二维差分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">1.1.13.</span> <span class="toc-text">位运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.14.</span> <span class="toc-text">双指针算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%BB%E6%95%A3%E5%8C%96"><span class="toc-number">1.1.15.</span> <span class="toc-text">离散化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6"><span class="toc-number">1.1.16.</span> <span class="toc-text">区间合并</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">第二章 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">单链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">双链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">1.2.3.</span> <span class="toc-text">栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E9%98%9F%E5%88%97"><span class="toc-number">1.2.4.</span> <span class="toc-text">普通队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.2.5.</span> <span class="toc-text">循环队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-number">1.2.6.</span> <span class="toc-text">单调栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="toc-number">1.2.7.</span> <span class="toc-text">单调队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kmp"><span class="toc-number">1.2.8.</span> <span class="toc-text">KMP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#trie%E6%A0%91"><span class="toc-number">1.2.9.</span> <span class="toc-text">Trie 树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%B4%E7%B4%A0%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">1.2.10.</span> <span class="toc-text">朴素并查集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%B4%E6%8A%A4size%E7%9A%84%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">1.2.11.</span> <span class="toc-text">维护 size 的并查集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%B4%E6%8A%A4%E5%88%B0%E7%A5%96%E5%AE%97%E8%8A%82%E7%82%B9%E8%B7%9D%E7%A6%BB%E7%9A%84%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">1.2.12.</span> <span class="toc-text">维护到祖宗节点距离的并查集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">1.2.13.</span> <span class="toc-text">堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E5%93%88%E5%B8%8C%E6%8B%89%E9%93%BE%E6%B3%95"><span class="toc-number">1.2.14.</span> <span class="toc-text">一般哈希：拉链法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E5%93%88%E5%B8%8C%E5%BC%80%E6%94%BE%E5%AF%BB%E5%9D%80%E6%B3%95"><span class="toc-number">1.2.15.</span> <span class="toc-text">一般哈希：开放寻址法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C"><span class="toc-number">1.2.16.</span> <span class="toc-text">字符串哈希</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c-stl"><span class="toc-number">1.2.17.</span> <span class="toc-text">c++ STL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA"><span class="toc-number">1.3.</span> <span class="toc-text">第三章 搜索与图论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">树与图的存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">邻接表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.3.</span> <span class="toc-text">树与图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">深度优先遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">宽度优先遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">1.3.4.</span> <span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%B4%E7%B4%A0dijkstra%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.5.</span> <span class="toc-text">朴素 dijkstra 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E4%BC%98%E5%8C%96%E7%89%88dijkstra"><span class="toc-number">1.3.6.</span> <span class="toc-text">堆优化版 dijkstra</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bellman-ford%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.7.</span> <span class="toc-text">Bellman-Ford 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spfa-%E7%AE%97%E6%B3%95%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96%E7%9A%84bellman-ford%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.8.</span> <span class="toc-text">spfa 算法（队列优化的 Bellman-Ford 算法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spfa%E5%88%A4%E6%96%AD%E5%9B%BE%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E8%B4%9F%E7%8E%AF"><span class="toc-number">1.3.9.</span> <span class="toc-text">spfa 判断图中是否存在负环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#floyd%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.10.</span> <span class="toc-text">floyd 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%B4%E7%B4%A0%E7%89%88prim%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.11.</span> <span class="toc-text">朴素版 prim 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kruskal%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.12.</span> <span class="toc-text">Kruskal 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%93%E8%89%B2%E6%B3%95%E5%88%A4%E5%88%AB%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="toc-number">1.3.13.</span> <span class="toc-text">染色法判别二分图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.14.</span> <span class="toc-text">匈牙利算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86"><span class="toc-number">1.4.</span> <span class="toc-text">第四章 数学知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%95%E9%99%A4%E6%B3%95%E5%88%A4%E5%AE%9A%E8%B4%A8%E6%95%B0"><span class="toc-number">1.4.1.</span> <span class="toc-text">试除法判定质数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%95%E9%99%A4%E6%B3%95%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0"><span class="toc-number">1.4.2.</span> <span class="toc-text">试除法分解质因数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%B4%E7%B4%A0%E7%AD%9B%E6%B3%95%E6%B1%82%E7%B4%A0%E6%95%B0"><span class="toc-number">1.4.3.</span> <span class="toc-text">朴素筛法求素数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E7%AD%9B%E6%B3%95%E6%B1%82%E7%B4%A0%E6%95%B0"><span class="toc-number">1.4.4.</span> <span class="toc-text">线性筛法求素数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%95%E9%99%A4%E6%B3%95%E6%B1%82%E6%89%80%E6%9C%89%E7%BA%A6%E6%95%B0"><span class="toc-number">1.4.5.</span> <span class="toc-text">试除法求所有约数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C%E7%BA%A6%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">1.4.6.</span> <span class="toc-text">约数个数和约数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.7.</span> <span class="toc-text">欧几里得算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.8.</span> <span class="toc-text">求欧拉函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%9B%E6%B3%95%E6%B1%82%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.9.</span> <span class="toc-text">筛法求欧拉函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-number">1.4.10.</span> <span class="toc-text">快速幂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.11.</span> <span class="toc-text">扩展欧几里得算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83"><span class="toc-number">1.4.12.</span> <span class="toc-text">高斯消元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%B3%95%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0"><span class="toc-number">1.4.13.</span> <span class="toc-text">递归法求组合数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E9%A2%84%E5%A4%84%E7%90%86%E9%80%86%E5%85%83%E7%9A%84%E6%96%B9%E5%BC%8F%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0"><span class="toc-number">1.4.14.</span> <span class="toc-text">通过预处理逆元的方式求组合数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lucas%E5%AE%9A%E7%90%86"><span class="toc-number">1.4.15.</span> <span class="toc-text">Lucas 定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0%E6%B3%95%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0"><span class="toc-number">1.4.16.</span> <span class="toc-text">分解质因数法求组合数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0"><span class="toc-number">1.4.17.</span> <span class="toc-text">卡特兰数</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2023/05/23/computer-science/notes/ACM%E3%80%81OI%E3%80%81IOI%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D/" rel="bookmark" title="编程竞赛模式介绍">编程竞赛模式介绍</a></li><li><a href="/2023/05/23/computer-science/notes/DFS%E5%92%8CBFS/" rel="bookmark" title="BFS、DFS">BFS、DFS</a></li><li><a href="/2023/05/23/computer-science/notes/P-NP%E9%97%AE%E9%A2%98/" rel="bookmark" title="P-NP">P-NP</a></li><li><a href="/2023/05/23/computer-science/notes/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="bookmark" title="动态规划">动态规划</a></li><li><a href="/2023/05/23/computer-science/notes/%E5%8D%A1%E5%B8%B8/" rel="bookmark" title="卡常小知识">卡常小知识</a></li><li><a href="/2023/05/23/computer-science/notes/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/" rel="bookmark" title="复杂度分析">复杂度分析</a></li><li><a href="/2023/05/23/computer-science/notes/%E6%8E%92%E5%BA%8F/" rel="bookmark" title="排序">排序</a></li><li class="active"><a href="/2023/05/23/computer-science/notes/%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/" rel="bookmark" title="算法板子">算法板子</a></li><li><a href="/2023/05/23/computer-science/notes/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/" rel="bookmark" title="进制转换">进制转换</a></li><li><a href="/2023/05/23/computer-science/notes/%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E5%BF%83%E5%BE%97/" rel="bookmark" title="自增自减">自增自减</a></li><li><a href="/2023/05/23/computer-science/notes/%E5%AE%8F%E5%AE%9A%E4%B9%89/" rel="bookmark" title="宏定义">宏定义</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="十月秋枫" data-src="/images/avatar.jpg"><p class="name" itemprop="name">十月秋枫</p><div class="description" itemprop="description">欢迎来到我的笔记空间꒰⑅•ᴗ•⑅꒱,在这里,你可以阅读我的学习笔记并提出独到的见解~我们将互相学习交流知识,共同进步( ๑╹ ꇴ╹) ｸﾞｯ!</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">22</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">7</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">3</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tLzEwMDEwMDAxMDExMDAx" title="https:&#x2F;&#x2F;github.com&#x2F;10010001011001"><i class="ic i-github"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tLw==" title="https:&#x2F;&#x2F;www.bilibili.com&#x2F;"><i class="ic i-bilibili"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLw==" title="https:&#x2F;&#x2F;music.163.com&#x2F;"><i class="ic i-cloud-music"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9jaS16aGFuZy1oYW8teWktemh1LXhpYW8tNDI=" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;ci-zhang-hao-yi-zhu-xiao-42"><i class="ic i-zhihu"></i></span> <span class="exturl item about" data-url="aHR0cDovLzI1MDczMjIxMTcucXpvbmUucXEuY29t" title="http:&#x2F;&#x2F;2507322117.qzone.qq.com"><i class="ic i-address-card"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>links</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/05/23/computer-science/notes/ACM%E3%80%81OI%E3%80%81IOI%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/05/23/computer-science/notes/%E6%8E%92%E5%BA%8F/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/memo-list/" title="分类于 备忘清单">备忘清单</a> <i class="ic i-angle-right"></i> <a href="/categories/memo-list/quick-reference/" title="分类于 编程速查表">编程速查表</a></div><span><a href="/2023/05/23/memo-list/quick-reference/Linux%20%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8/" title="Linux 命令速查表">Linux 命令速查表</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/memo-list/" title="分类于 备忘清单">备忘清单</a> <i class="ic i-angle-right"></i> <a href="/categories/memo-list/quick-reference/" title="分类于 编程速查表">编程速查表</a></div><span><a href="/2023/05/23/memo-list/quick-reference/Java%20%E5%A4%87%E5%BF%98%E6%B8%85%E5%8D%95/" title="Java 备忘清单">Java 备忘清单</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/network/" title="分类于 计算机网络">计算机网络</a></div><span><a href="/2023/05/29/computer-science/network/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%B8%B8%E8%AF%86/" title="网安常识">网安常识</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/notes/" title="分类于 学习小记">学习小记</a></div><span><a href="/2023/05/23/computer-science/notes/%E6%8E%92%E5%BA%8F/" title="排序">排序</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/notes/" title="分类于 学习小记">学习小记</a></div><span><a href="/2023/05/23/computer-science/notes/P-NP%E9%97%AE%E9%A2%98/" title="P-NP">P-NP</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/notes/" title="分类于 学习小记">学习小记</a></div><span><a href="/2023/05/23/computer-science/notes/%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E5%BF%83%E5%BE%97/" title="自增自减">自增自减</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/network/" title="分类于 计算机网络">计算机网络</a></div><span><a href="/2023/05/17/computer-science/network/TCP%20IP%20%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/" title="TCP IP 网络模型">TCP IP 网络模型</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/memo-list/" title="分类于 备忘清单">备忘清单</a> <i class="ic i-angle-right"></i> <a href="/categories/memo-list/quick-reference/" title="分类于 编程速查表">编程速查表</a></div><span><a href="/2023/05/23/memo-list/quick-reference/C%20%E5%A4%87%E5%BF%98%E6%B8%85%E5%8D%95/" title="C 备忘清单">C 备忘清单</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/04/26/%E6%9E%AB%E5%8F%B6%E5%AE%9B/" title="欢迎来到我的个人网站！">欢迎来到我的个人网站！</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/notes/" title="分类于 学习小记">学习小记</a></div><span><a href="/2023/05/23/computer-science/notes/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/" title="进制转换">进制转换</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2015 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">十月秋枫 @ Red-Leaf</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/05/23/computer-science/notes/算法代码模板/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->